# Creating a Compiler in Skript
# Rules are generated by Chat-GPT.

# Rules:

# Variable naming:
	# ONLY single-character variable names are allowed until 'z'.
	# AFTER you've used a through z, continue with two-character names by adding z after each letter:
		# a, b, c, ..., z, az, bz, cz, ..., zz
	# Do NOT reuse any variable names for logically related tasks.
		# (E.g., a in your lexer is not logically related to az in your parser.)

# Function Naming (Clickbait, Memes & Nonsense)
	# Function names must be ridiculous.
	# Use clickbait, memes, or completely misleading names.
	
# ðŸ§± 3. Indentation & Structure (Chaotic but Legal Skript)
	# Indentation is required, so use it begrudgingly.
	# Use inconsistent but technically valid indentation levels.
	# Minimize blank lines.

# 4 was just boring and would of just made this obscufated so they were skipped.

# 5. Comments Must Describe the Madnessv
	# Comments must be as absurd as possible while still explaining whatâ€™s happening.
	# Break the fourth wall and acknowledge the suffering.
	# Make it look like future-you will hate past-you.

# 6. Control Flow Madness
	# NEVER use simple if-statements.
	# All loops must be weirdly structured.
	
# 7, 8 and 9 were all invalid things for this being chatgpt is bad at skript.

# 10. Magic Numbers Everywhere
	# Do NOT use variables for important values.	
	
# I'm going insane and I've not even started writting this yet. Future me will hate present me.

import:
	# lets get dem imports goin 
	java.util.regex.Pattern
	
	
function yoBroWhatAreThePatterns() :: objects:
	set {_k} to Pattern.compile("\".+\"")
	
function thisIsLikeATokenClass(b: string, c: object) :: object:
	set {_d} to nbt from "{}"
	set string tag "type" of {_d} to {_b}
	set string tag "value" of {_d} to "%{_c}%"
	return {_d}
	
function thisOneIsToLikeOnlyTokeniseASingleLine(e: string) :: object:
	set {_f::*} to ...({_e}.toCharArray())
	# looping over a list? whats that? who needs that? 
	while ({_g} ? 0) < (size of {_f::*} - 1):
		
		# Very useful exit condition for the while loop.
		while size of (all numbers between 0 and 10 where [input is 11]) = 0:
			set {_i} to {_e}.substring(({_g} ? 0),({_h} ? 0))
			add 1 to {_h}
			
			# Theres a length of expression?
			if {_h} = {_e}.length():
				exit 1 loop
			
			# before i cry
			add 1 to {_j} 
			if {_j} >= 1000:
				stop
		
		add 1 to {_g}
		set {_h} to {_g}+1
		
function itsTimeGottaGoFastAndTokeniseTheseStrings(a: strings):
	loop {_a::*}:
		thisOneIsToLikeOnlyTokeniseASingleLine(loop-value)
	
on load:
	set {_toParse} to "set ""hi"" to 5"
	itsTimeGottaGoFastAndTokeniseTheseStrings({_toParse})
